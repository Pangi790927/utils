# Nodes without a type don't construct a clasic vku::object_t, instead they are constructed based on
# their value: integer are identified by their integer value, shaders by the existance of
# shader_type, etc.
vert_spirv:
  shader_type: VKU_SPIRV_VERTEX
  # should also have a posible "path"
  source: |
    #version 450

    layout(binding = 0) uniform ubo_t {
      mat4 model;
      mat4 view;
      mat4 proj;
    } ubo;

    // This shows us that macros work, but not sure how this would work with includes afterwards
    // but, meh, I don't really care, I'll simply paste the code there whenever I see an include
    // directive (from path or from a known name, not sure how I will decide on the name resplve)
    #define APPLY_ASSIGN(x, y) x = y

    layout(location = 0) in vec3 in_pos;

    // those are referenced by
    layout(location = 1) in vec3 in_normal; // vku::vertex3d_t::get_input_desc()
    layout(location = 2) in vec3 in_color;
    layout(location = 3) in vec2 in_tex;

    layout(location = 0) out vec3 out_color;
    layout(location = 1) out vec2 out_tex_coord;

    void main() {
      gl_Position = ubo.proj * ubo.view * ubo.model * vec4(in_pos, 1.0);

      APPLY_ASSIGN(out_color, in_color);
      APPLY_ASSIGN(out_tex_coord, in_tex);

    }

frag_spirv:
  shader_type: VKU_SPIRV_FRAGMENT
  source: |
    #version 450

    layout(location = 0) in vec3 in_color;      // this is referenced by the vert shader
    layout(location = 1) in vec2 in_tex_coord;  // this is referenced by the vert shader

    layout(location = 0) out vec4 out_color;
    layout(binding = 1) uniform sampler2D tex_sampler;

    void main() {
      out_color = vec4(in_color, 1.0);
      out_color = texture(tex_sampler, in_tex_coord);
    }

width: 800
height: 600

# TODO: figure those out: 
vertex_source:
  type: vkc::lua_var_t
index_source:
  type: vkc::lua_var_t
input_desc_source:
  type: vkc::lua_var_t
mvp_source:
  type: vkc::lua_var_t

inst:
  type: vku::instance_t
window:
  type: vku::window_t
  width: !ref width
  height: !ref height
  name: "Window Name Goes Here"
surf:
  type: vku::surface_t
  window: !ref window
  instance: !ref inst
dev:
  type: vku::device_t
  surface: !ref surf
cp:
  type: vku::cmdpool_t
  device: !ref dev
img:
  type: vku::image_t
  cmdpool: !ref cp
  path: test_image.png
view:
  type: vku::img_view_t
  image: !ref img
  aspect_mask: VK_IMAGE_ASPECT_COLOR_BIT
sampl:
  type: vku::img_sampl_t
  device: !ref dev
mvp_buff:
  type: vku::buffer_t
  device: !ref dev
  source: !ref mvp_source
  usage_flags: VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT
  sharing_mode: VK_SHARING_MODE_EXCLUSIVE
  memory_flags: VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
bindings:
  type: vku::binding_desc_t
  descriptors:
    # all should have the alternate posibility to be nested and have another "tag" option
    # this would be especially usefull here, where we could've instead hust nest view instead of
    # declaring it before it was needed
    - type: vku::binding_desc_set_t::buff_binding_t
      buff: !ref mvp_buff
    - type: vku::binding_desc_set_t::sampl_binding_t
      view: !ref view
      sampler: !ref sampl
vert:
  type: vku::shader_t
  device: !ref dev
  spirv: !ref vert_spirv
frag:
  type: vku::shader_t
  device: !ref dev
  spirv: !ref frag_spirv
swc:
  type: vku::swapchain_t
  device: !ref dev
rp:
  type: vku::renderpass_t
  swapchain: !ref swc
pl:
  type: vku::pipeline_t
  width: !ref width
  height: !ref height
  renderpass: !ref rp
  shaders:
    - !ref vert
    - !ref frag
  topology: VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST
  input_desc: !ref input_desc_source
  bindings: !ref bindings
fbs:
  type: vku::framebuffs_t
  renderpass: !ref rp
img_sem:
  type: vku::sem_t
  device: !ref dev
draw_sem:
  type: vku::sem_t
  device: !ref dev
fence:
  type: vku::fence_t
  device: !ref dev
cbuff:
  type: vku::cmdbuff_t
  cmdpool: !ref cp
vbuff:
  type: vku::buffer_t
  device: !ref dev
  source: !ref vertex_source
  usage_flags: VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT
  sharing_mode: VK_SHARING_MODE_EXCLUSIVE
  memory_flags: VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
ibuff:
  type: vku::buffer_t
  device: !ref dev
  source: !ref index_source
  usage_flags: VK_BUFFER_USAGE_INDEX_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT
  sharing_mode: VK_SHARING_MODE_EXCLUSIVE
  memory_flags: VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
desc_pool:
  type: vku::desc_pool_t
  device: !ref dev
  bindings: !ref bindings
  cnt: 1
desc_set:
  type: vku::desc_set_t
  descritpor_pool: !ref desc_pool
  pipeline: !ref pl
  bindings: !ref bindings

lua-script:
  source: |
    vku = require("vulkan_utils")

    function on_loop_run() do
      vku.glfw_pool_events() -- needed for keys to be available
      if vku.get_key(vku.window, vku.GLFW_KEY_ESCAPE) == vku.GLFW_PRESS then
        vku.signal_close() -- this will close the loop
      end

      img_idx = vku.aquire_next_img(vku.swc, vku.img_sem)

      -- do mvp update somehow?

      vku.cbuff.begin()
      vku.cbuff.begin_rpass(vku.fbs, img_idx)
      vku.cbuff.bind_vert_buffs(0, {{vku.vbuff, 0}});
      vku.cbuff.bind_idx_buff(vku.ibuff, 0, vku.VK_INDEX_TYPE_UINT16);
      vku.cbuff.bind_desc_set(vku.VK_PIPELINE_BIND_POINT_GRAPHICS, vku.pl, vku.desc_set);
      vku.cbuff.draw_idx(vku.pl, indices.size());
      vku.cbuff.end_rpass();
      vku.cbuff.end();

      vku.submit_cmdbuff({{vku.img_sem, vku.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT}},
          vku.cbuff, vku.fence, {vku.draw_sem})
      vku.present(vku.swc, {vku.draw_sem}, img_idx)

      vku.wait_fences({vku.fence})
      vku.reset_fences({vku.fence})
    end

    function on_window_resize(w, h)
      vku.device_wait_handle(vku.dev)

      vku.window.set_width(w)
      vku.window.set_height(h)

      -- this will recurse and rebuild all dependees on window
      vku.window.rebuild()
