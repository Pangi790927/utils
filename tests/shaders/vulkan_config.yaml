# Nodes without a type don't construct a clasic vku::object_t, instead they are constructed based on
# their value: integer are identified by their integer value, shaders by the existance of
# shader_type, etc.
vert_spirv:
  m_shader_type: VKU_SPIRV_VERTEX
  # should also have a posible "path"
  m_source: |
    #version 450

    layout(binding = 0) uniform ubo_t {
      mat4 model;
      mat4 view;
      mat4 proj;
    } ubo;

    // This shows us that macros work, but not sure how this would work with includes afterwards
    // but, meh, I don't really care, I'll simply paste the code there whenever I see an include
    // directive (from path or from a known name, not sure how I will decide on the name resplve)
    #define APPLY_ASSIGN(x, y) x = y

    layout(location = 0) in vec3 in_pos;

    // those are referenced by
    layout(location = 1) in vec3 in_normal; // vku::vertex3d_t::get_input_desc()
    layout(location = 2) in vec3 in_color;
    layout(location = 3) in vec2 in_tex;

    layout(location = 0) out vec3 out_color;
    layout(location = 1) out vec2 out_tex_coord;

    void main() {
      gl_Position = ubo.proj * ubo.view * ubo.model * vec4(in_pos, 1.0);

      APPLY_ASSIGN(out_color, in_color);
      APPLY_ASSIGN(out_tex_coord, in_tex);

    }

frag_spirv:
  m_shader_type: VKU_SPIRV_FRAGMENT
  m_source: |
    #version 450

    layout(location = 0) in vec3 in_color;      // this is referenced by the vert shader
    layout(location = 1) in vec2 in_tex_coord;  // this is referenced by the vert shader

    layout(location = 0) out vec4 out_color;
    layout(binding = 1) uniform sampler2D tex_sampler;

    void main() {
      out_color = vec4(in_color, 1.0);
      out_color = texture(tex_sampler, in_tex_coord);
    }

width: 800
height: 600

# TODO: figure those out: 
vertex_source:
  m_type: vkc::lua_var_t
index_source:
  m_type: vkc::lua_var_t
input_desc_source:
  m_type: vkc::lua_var_t
mvp_source:
  m_type: vkc::lua_var_t

inst:
  m_type: vku::instance_t
window:
  m_type: vku::window_t
  m_width: !ref width
  m_height: !ref height
  m_name: "Window Name Goes Here"
surf:
  m_type: vku::surface_t
  m_window: !ref window
  m_instance: !ref inst
cp:
  m_type: vku::cmdpool_t
  m_device:
    dev:
      m_type: vku::device_t
      m_surface: !ref surf
view:
  m_type: vku::img_view_t
  m_image:
    m_type: vku::image_t
    m_tag: img
    m_cmdpool: !ref cp
    m_path: test_image.png
  m_aspect_mask: VK_IMAGE_ASPECT_COLOR_BIT
sampl:
  m_type: vku::img_sampl_t
  m_device: !ref dev
mvp_buff:
  m_type: vku::buffer_t
  m_device: !ref dev
  m_source: !ref mvp_source
  m_usage_flags: VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT
  m_sharing_mode: VK_SHARING_MODE_EXCLUSIVE
  m_memory_flags: VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
bindings:
  m_type: vku::binding_desc_set_t
  m_descriptors:
    # all should have the alternate posibility to be nested and have another "tag" option
    # this would be especially usefull here, where we could've instead hust nest view instead of
    # declaring it before it was needed
    - m_type: vku::binding_desc_set_t::buff_binding_t
      m_buff: !ref mvp_buff
    - m_type: vku::binding_desc_set_t::sampl_binding_t
      m_view: !ref view
      m_sampler: !ref sampl
vert:
  m_type: vku::shader_t
  m_device: !ref dev
  m_spirv: !ref vert_spirv
frag:
  m_type: vku::shader_t
  m_device: !ref dev
  m_spirv: !ref frag_spirv
swc:
  m_type: vku::swapchain_t
  m_device: !ref dev
rp:
  m_type: vku::renderpass_t
  m_swapchain: !ref swc
pl:
  m_type: vku::pipeline_t
  m_width: !ref width
  m_height: !ref height
  m_renderpass: !ref rp
  m_shaders:
    - !ref vert
    - !ref frag
  m_topology: VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST
  m_input_desc: !ref input_desc_source
  m_bindings: !ref bindings
fbs:
  m_type: vku::framebuffs_t
  m_renderpass: !ref rp
img_sem:
  m_type: vku::sem_t
  m_device: !ref dev
draw_sem:
  m_type: vku::sem_t
  m_device: !ref dev
fence:
  m_type: vku::fence_t
  m_device: !ref dev
cbuff:
  m_type: vku::cmdbuff_t
  m_cmdpool: !ref cp
vbuff:
  m_type: vku::buffer_t
  m_device: !ref dev
  m_source: !ref vertex_source
  m_usage_flags: VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT
  m_sharing_mode: VK_SHARING_MODE_EXCLUSIVE
  m_memory_flags: VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
ibuff:
  m_type: vku::buffer_t
  m_device: !ref dev
  m_source: !ref index_source
  m_usage_flags: VK_BUFFER_USAGE_INDEX_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT
  m_sharing_mode: VK_SHARING_MODE_EXCLUSIVE
  m_memory_flags: VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
desc_pool:
  m_type: vku::desc_pool_t
  m_device: !ref dev
  m_bindings: !ref bindings
  m_cnt: 1
desc_set:
  m_type: vku::desc_set_t
  m_descritpor_pool: !ref desc_pool
  m_pipeline: !ref pl
  m_bindings: !ref bindings

lua_script:
  m_source: |
    vku = require("vulkan_utils")

    function on_loop_run() do
      vku.glfw_pool_events() -- needed for keys to be available
      if vku.get_key(vku.window, vku.GLFW_KEY_ESCAPE) == vku.GLFW_PRESS then
        vku.signal_close() -- this will close the loop
      end

      img_idx = vku.aquire_next_img(vku.swc, vku.img_sem)

      -- do mvp update somehow?

      vku.cbuff.begin()
      vku.cbuff.begin_rpass(vku.fbs, img_idx)
      vku.cbuff.bind_vert_buffs(0, {{vku.vbuff, 0}});
      vku.cbuff.bind_idx_buff(vku.ibuff, 0, vku.VK_INDEX_TYPE_UINT16);
      vku.cbuff.bind_desc_set(vku.VK_PIPELINE_BIND_POINT_GRAPHICS, vku.pl, vku.desc_set);
      vku.cbuff.draw_idx(vku.pl, indices.size());
      vku.cbuff.end_rpass();
      vku.cbuff.end();

      vku.submit_cmdbuff({{vku.img_sem, vku.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT}},
          vku.cbuff, vku.fence, {vku.draw_sem})
      vku.present(vku.swc, {vku.draw_sem}, img_idx)

      vku.wait_fences({vku.fence})
      vku.reset_fences({vku.fence})
    end

    function on_window_resize(w, h)
      vku.device_wait_handle(vku.dev)

      vku.window.set_width(w)
      vku.window.set_height(h)

      -- this will recurse and rebuild all dependees on window
      vku.window.rebuild()


# WIP TUTORIAL
# 
# 
# How objects work in the configuration file:
# ===========================================
#
# 1. Declaring a standalone object:
#    An object can be defined on its own, using a tag name as its identifier:
#
#    ```yaml
#     tag-name:
#         m_type: object_type
#         ...
#    ```
#
#    In this form:
#
#    * The tag name (e.g., `tag-name`) is automatically treated as the object's type identifier.
#    * The field `m_type` is required â€” it marks the entry as an object.
#    * Other properties or fields may follow.
#
# 2. Declaring an object within another object:
#    An object can also appear as a nested field inside another object:
#
#    ```yaml
#     another-tag-name:
#         ...
#         m_field:
#             tag-name:
#                 m_type: object_type
#                 ...
#    ```
#
#    In this case:
#
#    * `m_field` contains an object named `tag-name`.
#    * `tag-name` again includes an `m_type` to specify its type.
#
# 3. Declaring an inline (anonymous) object:
#    You can define an object directly within a field without giving it an outer tag.
#    However, you may optionally include an `m_tag` if you plan to reference it later:
#
#    ```yaml
#     another-tag-name:
#         ...
#         m_field:
#             m_type: object_type
#             m_tag: optional-tag-name
#    ```
#
#    Here:
#
#    * `m_type` identifies the object type.
#    * `m_tag` (optional) assigns a reference name so this object can be reused elsewhere.